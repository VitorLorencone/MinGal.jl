var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"Julia References","title":"References","text":"","category":"section"},{"location":"references/","page":"Julia References","title":"Julia References","text":"Here you will find all the docstring documentation for the implemented functions.","category":"page"},{"location":"references/#Main.MinGal.Algebra","page":"Julia References","title":"Main.MinGal.Algebra","text":"Algebra(p, [q], [r], [symbols], [type])::Algebra\n\nMain function for creating your Algebra and adding its basis blades to REPL. Constructor Function of an algebraic object with parameters p, q, r, R^{p, q, r}, and its multivector space. If not defined, the last two parameters are automatically calculated as canonical.\n\nArguments\n\np::Int : Represents the ammount of positive dimensions\nq::Int : Represents the ammount of negative dimensions\nr::Int : Represents the ammount of null dimensions\nsymbols::Vector{String} : Array of primary symbols for the Algebra\ntype::String : String for manually selecting \"full\", \"min\" or \"special\" Algebras\n\nReturn\n\nReturns the created Algebra object.\n\n\n\n\n\n","category":"type"},{"location":"references/#Main.MinGal.AlgebraFull","page":"Julia References","title":"Main.MinGal.AlgebraFull","text":"AlgebraFull(p, q, r, symbols, basis, basis_bit_order, metric, max)\n\nA structure to define an algebra to be worked with its respective dimensions and canonical vectors.\n\nFields\n\np::Int : Represents the ammount of positive dimensions\nq::Int : Represents the ammount of negative dimensions\nr::Int : Represents the ammount of null dimensions\nsymbols::Vector{String} : Array of primary symbols for the Algebra\nbasis::Vector{String} : Array of all symbols for the Algebra, normal order\nbasis_bit_order::Vector{String} : Array of symbols for the Algebra, bit order\nblades::Dict{Symbol, Any} : Array of all multivectors generated for this algebra\nmetric::Vector{Int8} : Another way of representing the algebra signature\nmax::Integer : max number of Algebra elements, the same as 2^(p+q+r)\n\n\n\n\n\n","category":"type"},{"location":"references/#Main.MinGal.AlgebraMin","page":"Julia References","title":"Main.MinGal.AlgebraMin","text":"AlgebraMin(p, q, r, symbols, metric, max)\n\nA structure to define an algebra to be worked with its respective dimensions and canonical vectors.\n\nFields\n\np::Int : Represents the ammount of positive dimensions\nq::Int : Represents the ammount of negative dimensions\nr::Int : Represents the ammount of null dimensions\nsymbols::Vector{String} : Array of primary symbols for the Algebra\nblades::Dict{Symbol, Any} : Array of all multivectors generated for this algebra\nmetric::Vector{Int8} : Another way of representing the algebra signature\nmax::Int : max number of Algebra elements, the same as 2^(p+q+r)\n\n\n\n\n\n","category":"type"},{"location":"references/#Main.MinGal.Blade","page":"Julia References","title":"Main.MinGal.Blade","text":"Blade(bitmap, scalar, al::Algebra)::Blade ||\nBlade(mv::Multivector)::Blade ||\nBlade(k::Number, al::Algebra)::Blade\n\nCreates a Blade based on bitmap and Scalars or Converts a multivector into a blade. It may throw an error\n\nArguments\n\nbitmap::Integer : The bitmap that specifies what basis vectors are present in this blade \nscalar::Number : The scalar of the basis blade.\nal::Algebra : The current algebra on use.\n\n||\n\nmv::Multivector\n\n||\n\nk::Number\nal::Algebra : The current algebra on use.\n\nReturn\n\nReturns a Blade.\n\n\n\n\n\n","category":"type"},{"location":"references/#Main.MinGal.Blade-2","page":"Julia References","title":"Main.MinGal.Blade","text":"Blade(blade_array)\n\nStruct that creates the Blade object. The bitmap that specifies what basis vectors are present in this blade  and The scalar of the basis blade.\n\nArguments\n\nbasis blades and their scalars.\n\n\n\n\n\n","category":"type"},{"location":"references/#Main.MinGal.Multivector","page":"Julia References","title":"Main.MinGal.Multivector","text":"Multivector(base_vectors, scalars, al::Algebra) ||\nMultivector(bl::Blade) ||\nMultivector(blades::Array{Blade}, al::Algebra)\n\nConstructor function for creating multivectors.\n\nArguments\n\nbase_vectors::Vector{Integer} : An array of integers, representing the actual basis blade that exists in this object in bit order.\nscalars::Vector{Number} : An array of Floats, representing the scalars of each basis blade in bit order.\nal::Algebra : The current algebra on use.\n\n||\n\nbl::Blade : A Blade, to convert to Multivector.\n\n||\n\nblades::GAVector : An array of Blades, to convert to Multivector.\nal::Algebra : The current algebra on use.\n\nReturn\n\nReturns a Multivector.\n\n\n\n\n\n","category":"type"},{"location":"references/#Main.MinGal.Multivector-2","page":"Julia References","title":"Main.MinGal.Multivector","text":"Multivector(blade_array)\n\nStruct that creates the multivector object.\n\nArguments\n\nblade_array::SparseArrays.SparseVector{Number, Integer} : An sparse vector with the internal values of \n\nbasis blades and their scalars.\n\n\n\n\n\n","category":"type"},{"location":"references/#Main.MinGal.binary_index_map-Tuple{Vector{String}, Vector{String}}","page":"Julia References","title":"Main.MinGal.binary_index_map","text":"binary_index_map(base, basis)::Dict{Int, Int}\n\nFunction that maps the index of normal and bit order.\n\nArguments\n\nbase::Vector{String} : An array of strings to be combined.\nbasis::Vector{String} : An array of the final combination of strings.\n\nReturn\n\nReturns a dict with all the mapped values.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.bitmap-Tuple{Blade}","page":"Julia References","title":"Main.MinGal.bitmap","text":"bitmap(bl::Blade)::Integer\n\nReturns the bitmap of the Blade\n\nArguments\n\nbl::Blade\n\nReturn\n\nThe bitmap\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.canon_basis-Tuple{Vector{String}}","page":"Julia References","title":"Main.MinGal.canon_basis","text":"canon_basis(symbols)::Vector{String}\n\nFunction that lists all the combinations of canonical vectors in a given Algebra.\n\nArguments\n\nsymbols::Vector{String} : An array of strings to be combined.\n\nReturn\n\nReturns a list with all combinations of the elements, forming the basis of the multivector space.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.canon_basis_bit_order-Tuple{Any}","page":"Julia References","title":"Main.MinGal.canon_basis_bit_order","text":"canon_basis_bit_order(symbols)::Vector{String}\n\nFunction that lists all the combinations of canonical vectors in a given Algebra in bit order.\n\nArguments\n\nsymbols::Vector{String} : An array of strings to be combined.\n\nReturn\n\nReturns a list with all combinations of the elements, forming the basis of the multivector space, in bit order.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.canon_symbols","page":"Julia References","title":"Main.MinGal.canon_symbols","text":"canon_symbols(p, [q], [r])::Vector{String}\n\nFunction that writes the canonical vector space symbols, given the parameters p, q and r for definition\n\nArguments\n\np::Int : Represents the ammount of positive dimensions\nq::Int : Represents the ammount of negative dimensions\nr::Int : Represents the ammount of null dimensions\n\nReturn\n\nReturn an array of strings with all the necessary elements for this space.\n\n\n\n\n\n","category":"function"},{"location":"references/#Main.MinGal.canonical_basis","page":"Julia References","title":"Main.MinGal.canonical_basis","text":"canonical_basis(al::Algebra)::GAVector\n\nFunction that returns an iterable list with only the canonical basis blades\n\nArguments\n\nal::Algebra\n\nReturn\n\nA Vector (GAVector) with only the canonical basis blades\n\n\n\n\n\n","category":"function"},{"location":"references/#Main.MinGal.canonical_reordering_sign-Tuple{Blade, Blade}","page":"Julia References","title":"Main.MinGal.canonical_reordering_sign","text":"canonical_reordering_sign(ei, ej)::Integer\n\nFunction that computes the reordering of a Blade to get into canonical order.\n\nArguments\n\nei::Blade\nej::Blade\n\nReturn\n\nThe sign value, either 1 or -1.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.chain","page":"Julia References","title":"Main.MinGal.chain","text":"chain(coeff::Vector, al::Algebra)::GAType\n\nFunction that 'chains' the canonical basis with a vector of coefficients. It sums the coeff[i]*canonical[i] with the rest, good for translating matrices lines into a GA object.\n\nArguments\n\ncoeff::Vector\nal::Algebra\n\nReturn\n\na single GAType, the chained value\n\n\n\n\n\n","category":"function"},{"location":"references/#Main.MinGal.change_algebra-Tuple{Algebra}","page":"Julia References","title":"Main.MinGal.change_algebra","text":"change_algebra(al::Algebra)\n\nChange the algebra REPL symbols on use. Not recomended because of time complexity. Prefer using dot notation when working with multiple algebras.\n\nArguments\n\nal::Algebra\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.clifford_conjugation-Tuple{GAType}","page":"Julia References","title":"Main.MinGal.clifford_conjugation","text":"clifford_conjugation(ei::GAType)::GAType\n\nFunction that computes the Clifford Conjugation of a multivector and return its result.\n\nArguments\n\nei::Multivector\n\nReturn\n\nThe Clifford Conjugate of ei.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.clifford_norm-Tuple{GAType}","page":"Julia References","title":"Main.MinGal.clifford_norm","text":"clifford_norm(ei::GAType)::Number\n\nFunction that computes the clifford norm of a GAType.\n\nArguments\n\nei::GAType\n\nReturn\n\nThe clifford norm of ei.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.conjugate-Tuple{GAType}","page":"Julia References","title":"Main.MinGal.conjugate","text":"conjugate(ei::GAType)::GAType\n\nFunction that computes the conjugate of a multivector and return its result.\n\nArguments\n\nei::Multivector\n\nReturn\n\nThe conjugate of ei.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.conjugate_norm-Tuple{GAType}","page":"Julia References","title":"Main.MinGal.conjugate_norm","text":"conjugate_norm(ei::GAType)::Number\n\nFunction that computes the conjugate norm of a GAType. Also another possible norm for degenerate algebras.\n\nArguments\n\nei::GAType\n\nReturn\n\nThe conjugate norm of ei.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.create_algebra","page":"Julia References","title":"Main.MinGal.create_algebra","text":"create_algebra(p, [q], [r], [symbols])\n\nConstructor Function of an algebraic object with signature p, q, r. If not defined,  the symbols for the algebra are automatically calculated as canonical.\n\nArguments\n\np::Int : Represents the ammount of positive dimensions\nq::Int : Represents the ammount of negative dimensions\nr::Int : Represents the ammount of null dimensions\nsymbols::Vector{String} : Array of primary symbols for the Algebra\n\nReturn\n\nReturns the created Algebra object.\n\n\n\n\n\n","category":"function"},{"location":"references/#Main.MinGal.create_algebra_min","page":"Julia References","title":"Main.MinGal.create_algebra_min","text":"create_algebra_min(p, [q], [r])\n\nConstructor Function of an algebraic object with signature p, q, r. There are no symbos in the \"min\" algebra representation.\n\nArguments\n\np::Int : Represents the ammount of positive dimensions\nq::Int : Represents the ammount of negative dimensions\nr::Int : Represents the ammount of null dimensions\n\nReturn\n\nReturns the created Algebra object.\n\n\n\n\n\n","category":"function"},{"location":"references/#Main.MinGal.create_special_symbols-Tuple{Algebra}","page":"Julia References","title":"Main.MinGal.create_special_symbols","text":"create_special_symbols()\n\nCreate and add to REPL the special symbols for this Algebra, such as the \"id\" for scalar GAType grade 0 and \"eI\" for the pseudoscalar of the space. \n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.create_symbols-Tuple{Algebra}","page":"Julia References","title":"Main.MinGal.create_symbols","text":"create_symbols(stringSymbols)\n\nCreate and add to REPL all the (custom or basis) symbols for this Algebra.\n\nArguments\n\nstring_symbols::Vector{String} : An array with all the custom or basis symbols.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.create_symbols_min-Tuple{Algebra}","page":"Julia References","title":"Main.MinGal.create_symbols_min","text":"create_symbols_min(stringSymbols)\n\nCreate and add to REPL the (custom or basis) symbols for this Algebra. But only the canonical basis blades symbols no combination between then.\n\nArguments\n\nstring_symbols::Vector{String} : An array with all the custom or basis symbols.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.describe-Tuple{Main.MinGal.AlgebraFull}","page":"Julia References","title":"Main.MinGal.describe","text":"describe(al::Algebra)\n\nDescribe function for showing the Algebra function.\n\nArguments\n\nal::Algebra : The algebra for printing\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.dual-Tuple{GAType}","page":"Julia References","title":"Main.MinGal.dual","text":"dual(ei::GAType)::GAType\n\nFunction that computes the dual of a multivector and return its result. Just be careful with parameter r > 0. It uses Polarity algorithm for invertible algebras and hodge dual for degenerate algebras.\n\nArguments\n\nei::Multivector\n\nReturn\n\nThe dual of ei.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.euclidean_norm-Tuple{GAType}","page":"Julia References","title":"Main.MinGal.euclidean_norm","text":"euclidean_norm(ei::GAType)::Number\n\nFunction that computes the euclidean coefficients norm of a GAType. It is also good for degenerate algebras because the metric is mostly ignored.\n\nArguments\n\nei::GAType\n\nReturn\n\nThe euclidean norm of ei.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.euclidean_scalar_product-Tuple{GAType, GAType}","page":"Julia References","title":"Main.MinGal.euclidean_scalar_product","text":"euclidean_scalar_product(ei, ej)::Number\n\nFunction that returns the Euclidean Scalar Product between two GAType.\n\nArguments\n\nei::GAType\nej::GAType\n\nReturn\n\nThe result product\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.exp_ga-Tuple{GAType}","page":"Julia References","title":"Main.MinGal.exp_ga","text":"exp_ga(ei::GAType)::GAType\n\nFunction that computes the exponential of elements that squares to a scalar. A more generic function was not yet implemented.\n\nArguments\n\nei::GAType\n\nReturn\n\nThe result GAType.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.geometric_product-Tuple{Blade, Blade}","page":"Julia References","title":"Main.MinGal.geometric_product","text":"geometric_product(ei, ej)::Multivector\n\nFunction that returns the Geometric Product between two blades.\n\nArguments\n\nei::Blade\nej::Blade\n\nReturn\n\nThe result Blade.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.geometric_product-Tuple{GAType, GAType}","page":"Julia References","title":"Main.MinGal.geometric_product","text":"geometric_product(ei::GAType, ej::GAType)::GAType\n\nFunction that computes the geometric product of two multivectors and return its result.\n\nArguments\n\nei::GAType\nej::GAType\n\nReturn\n\nThe result GAType.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.get_scalar-Tuple{GAType, Integer}","page":"Julia References","title":"Main.MinGal.get_scalar","text":"get_scalar(mv, k)::Number ||\nget_scalar(mv, ei)::Number\n\nFunction that returns the scalar value in index k from GAType mv. The index k follows the bit order basis.The ei value represents the  blade that you want the scalar from.\n\nArguments\n\nmv::GAType : A Blade or a Multivector.\nk::Integer : Index in bit order basis\n\n||\n\nmv::GAType : A Blade or a Multivector.\nei::Blade : Blade for Index\n\nReturn\n\nThe scalar value.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.grade-Tuple{Blade}","page":"Julia References","title":"Main.MinGal.grade","text":"grade(bl::Blade)::Integer ||\ngrade(mv::Multivector)::Integer\n\nFunction that returns the grade of the Blade or multivector.\n\nArguments\n\nbl::Blade\n\n||\n\nmv::Multivector\n\nReturn\n\nAn integer, the grade of the blade or multivector.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.grade_involution-Tuple{GAType}","page":"Julia References","title":"Main.MinGal.grade_involution","text":"grade_involution(ei::GAType)::GAType\n\nFunction that computes the grade involuction of a multivector and return its result.\n\nArguments\n\nei::Multivector\n\nReturn\n\nThe grade involution of ei.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.grade_minus-Tuple{Blade}","page":"Julia References","title":"Main.MinGal.grade_minus","text":"grade_minus(bl::Blade)::Integer\n\nFunction that returns the numbers of basis vectors in a basis blade that square to -1.\n\nArguments\n\nbl::Blade\n\nReturn\n\nAn integer, the grade- of the blade or multivector.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.grade_null-Tuple{Blade}","page":"Julia References","title":"Main.MinGal.grade_null","text":"grade_null(bl::Blade)::Integer\n\nFunction that returns the numbers of basis vectors in a basis blade that square to 0.\n\nArguments\n\nbl::Blade\n\nReturn\n\nAn integer, the grade0 of the blade or multivector.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.grade_plus-Tuple{Blade}","page":"Julia References","title":"Main.MinGal.grade_plus","text":"grade_plus(bl::Blade)::Integer\n\nFunction that returns the numbers of basis vectors in a basis blade that square to +1.\n\nArguments\n\nbl::Blade\n\nReturn\n\nAn integer, the grade+ of the blade or multivector.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.grade_projection-Tuple{Blade, Integer}","page":"Julia References","title":"Main.MinGal.grade_projection","text":"grade_projection(bl, k)::Blade ||\ngrade_projection(mv, k)::Blade\n\nFunction that returns the grade Projection between a Blade and an Integer. In the multivector form, it requires that it has only one blade.\n\nArguments\n\nbl::Blade\nk::Integer : The grade for projection\n\n||\n\nmv::Blade\nk::Integer : The grade for projection\n\nReturn\n\nThe result Blade. It might be the 1D blade \"1\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.grade_selection-Tuple{GAType, Number}","page":"Julia References","title":"Main.MinGal.grade_selection","text":"grade_selection(ei::GAType, k::Number)::GAType\n\nFunction that retrieves the k grade part of a GAType. Duplicated, since grade_projection  does the same, but a new algorithm and more generalized.\n\nArguments\n\nei::Multivector\nk::Number : The selected grade.\n\nReturn\n\nThe result GAType.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.has_key-Tuple{GAType, Integer}","page":"Julia References","title":"Main.MinGal.has_key","text":"has_key(mv, k)::Bool ||\nhas_key(mv, ei)::Bool\n\nFunction that checks if the GAType has a blade.\n\nArguments\n\nmv::GAType\nk::Integer : Index\n\n||\n\nmv::GAType\nei::Blade : Index\n\nReturn\n\nTrue, if yes, False, if not.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.inner_product-Tuple{Blade, Blade}","page":"Julia References","title":"Main.MinGal.inner_product","text":"inner_product(ei, ej)::Multivector\n\nFunction that returns the Inner Product between two blades.\n\nArguments\n\nei::Blade\nej::Blade\n\nReturn\n\nThe result Blade.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.inner_product-Tuple{GAType, GAType}","page":"Julia References","title":"Main.MinGal.inner_product","text":"inner_product(ei::GAType, ej::GAType)::GAType\n\nFunction that computes the outer product of two multivectors and return its result.\n\nArguments\n\nei::GAType\nej::GAType\n\nReturn\n\nThe result GAType.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.invert-Tuple{GAType}","page":"Julia References","title":"Main.MinGal.invert","text":"invert(ei::GAType)::GAType\n\nFunction that computes the inverse of a multivector (mostly versors and blades supported!) and return its result. May throw an error if not invertible.\n\nArguments\n\nei::GAType\n\nReturn\n\nThe inverse of ei.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.is_blade-Tuple{GAType}","page":"Julia References","title":"Main.MinGal.is_blade","text":"is_blade(ei::GAType)::Bool\n\nFunction that checks where a GAType is a Blade or not.\n\nArguments\n\nei::GAType\n\nReturn\n\nTrue if it's a Blade, False otherwise.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.is_scalar-Tuple{GAType}","page":"Julia References","title":"Main.MinGal.is_scalar","text":"is_scalar(ei::GAType)::Bool\n\nFunction that checks where a GAType is a Scalar or not.\n\nArguments\n\nei::GAType\n\nReturn\n\nTrue if it's a Scalar, False otherwise.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.left_contraction-Tuple{Blade, Blade}","page":"Julia References","title":"Main.MinGal.left_contraction","text":"left_contraction(ei::GAType, ej::GAType)::GAType\n\nFunction that computes the left contraction of two multivectors and return its result.\n\nArguments\n\nei::GAType\nej::GAType\n\nReturn\n\nThe result GAType.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.multivector_sub-Tuple{GAType, GAType}","page":"Julia References","title":"Main.MinGal.multivector_sub","text":"multivector_sub(mi::GAType, mj::GAType)::GAType\n\nFunction that subtracts two multivectors and return its result.\n\nArguments\n\nmi::GAType\nmj::GAType\n\nReturn\n\nThe result GAType.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.multivector_sum-Tuple{GAType, GAType}","page":"Julia References","title":"Main.MinGal.multivector_sum","text":"multivector_sum(mi::GAType, mj::GAType)::GAType\n\nFunction that sums two GAType and return its result.\n\nArguments\n\nmi::GAType\nmj::GAType\n\nReturn\n\nThe result Multivector.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.norm-Tuple{GAType}","page":"Julia References","title":"Main.MinGal.norm","text":"norm(ei::GAType)::Number\n\nFunction that computes the reverse norm in absolute value (conjugate norm) for a GAType on usual algebras.  For degenerate algebras, computes euclidean norm.\n\nArguments\n\nei::GAType\n\nReturn\n\nThe norm of ei.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.outer_product-Tuple{Blade, Blade}","page":"Julia References","title":"Main.MinGal.outer_product","text":"outer_product(ei, ej)::Multivector\n\nFunction that returns the Outer Product between two blades.\n\nArguments\n\nei::Blade\nej::Blade\n\nReturn\n\nThe result Blade.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.outer_product-Tuple{GAType, GAType}","page":"Julia References","title":"Main.MinGal.outer_product","text":"outer_product(ei::GAType, ej::GAType)::GAType\n\nFunction that computes the outer product of two multivectors and return its result.\n\nArguments\n\nei::GAType\nej::GAType\n\nReturn\n\nThe result GAType.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.product_by_scalar-Tuple{GAType, Number}","page":"Julia References","title":"Main.MinGal.product_by_scalar","text":"product_by_scalar(mv::GAType, k::Number)::GAType\n\nFunction that calculates the product by scalar between a blade and a scalar.\n\nArguments\n\nmv::GAType\nk::Number\n\nReturn\n\nThe result GAType.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.regressive_product-Tuple{Blade, Blade}","page":"Julia References","title":"Main.MinGal.regressive_product","text":"regressive_product(ei::GAType, ej::GAType)::GAType\n\nFunction that computes the regressive product of two multivectors and return its result.\n\nArguments\n\nei::GAType\nej::GAType\n\nReturn\n\nThe result GAType.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.reverse_norm-Tuple{GAType}","page":"Julia References","title":"Main.MinGal.reverse_norm","text":"reverse_norm(ei::GAType)::Number\n\nFunction that computes the reverse norm of a GAType on usual algebras. In practice  the reverse norm is useful, especially due to its possible negative sign\n\nArguments\n\nei::GAType\n\nReturn\n\nThe reverse norm of ei.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.revert-Tuple{GAType}","page":"Julia References","title":"Main.MinGal.revert","text":"revert(ei::GAType)::GAType\n\nFunction that computes the reverse of a multivector and return its result.\n\nArguments\n\nei::Multivector\n\nReturn\n\nThe reverse of ei.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.right_contraction-Tuple{Blade, Blade}","page":"Julia References","title":"Main.MinGal.right_contraction","text":"right_contraction(ei::GAType, ej::GAType)::GAType\n\nFunction that computes the right contraction of two multivectors and return its result.\n\nArguments\n\nei::GAType\nej::GAType\n\nReturn\n\nThe result GAType.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.scalar-Tuple{Blade}","page":"Julia References","title":"Main.MinGal.scalar","text":"scalar(bl::Blade)::Number||\nscalar(mv::Multivector)::Number\n\nReturns the scalar of the GAType\n\nArguments\n\nbl::Blade\nmv::Multivector\n\nReturn\n\nThe scalar\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.scalar_product-Tuple{GAType, GAType}","page":"Julia References","title":"Main.MinGal.scalar_product","text":"scalar_product(ei, ej)::Number\n\nFunction that returns the Scalar Product between two GAType.\n\nArguments\n\nei::GAType\nej::GAType\n\nReturn\n\nThe result product.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.scalar_product_basis-Tuple{GAType, GAType}","page":"Julia References","title":"Main.MinGal.scalar_product_basis","text":"scalar_product_basis(ei, ej)::Integer\n\nFunction that returns the Scalar Product between two basis blades.\n\nArguments\n\nei::Blade\nej::Blade\n\nReturn\n\nThe result Integer.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.set_scalar-Tuple{GAType, Number, Integer}","page":"Julia References","title":"Main.MinGal.set_scalar","text":"set_scalar(mv, val, k)::Number ||\nset_scalar(mv, val, ei)::Number\n\nFunction that changes the scalar value in index k from GAType mv. The index k follows the bit order basis.The ei value represents the  blade that you want to change the scalar from.\n\nArguments\n\nmv::GAType\nval::Number : New Value\nk::Integer : Index in bit order basis\n\n||\n\nmv::GAType\nval::Number : New Value\nei::Blade : Index\n\nReturn\n\nThe scalar value.\n\n\n\n\n\n","category":"method"},{"location":"references/#Main.MinGal.undual-Tuple{GAType}","page":"Julia References","title":"Main.MinGal.undual","text":"undual(ei::GAType)::GAType\n\nFunction that computes the undual of a multivector and return its result. Just be careful with r > 0. It uses Polarity algorithm for invertible  algebras and hodge dual for degenerate algebras.\n\nArguments\n\nei::Multivector\n\nReturn\n\nThe undual of ei.\n\n\n\n\n\n","category":"method"},{"location":"linear/#Linear-Systems","page":"Linear Systems","title":"Linear Systems","text":"","category":"section"},{"location":"linear/","page":"Linear Systems","title":"Linear Systems","text":"This example illustrates a function to solve linear systems using geometric algebra with Grassmann’s method. As noted in the limitations section, the code is not very efficient for slightly higher dimensions due to MinGal’s additive implementation.","category":"page"},{"location":"linear/","page":"Linear Systems","title":"Linear Systems","text":"function solve_linear_systems_projective(A::Array, b::Array)\n    # assume the inputs are always correct\n    D = size(A,1)\n    al = Algebra(D, 0, 1)\n\n    # Calculates the grassmann coeficients such as A1 = a*e1 + b*e2 +...- B1*e0\n    lines::GAVector = [chain([-b[i]; A[i,:]]) for i in 1:D]\n\n    mv = dual(reduce(^, lines; init=Blade(1)))\n    # mv = reduce(&, dual.(lines); init=al.eI) -> Alternative version\n\n    if(mv == 0)\n        error(\"Possible and Indeterminate System - Infinite Solutions\")\n    elseif(mv[al.e0] == 0)\n        error(\"Impossible System - No Solution\")\n    end\n\n    mv = mv/mv[al.e0]\n    ans = [mv[canonical_basis()[k+1]] for k in 1:D]\nend","category":"page"},{"location":"linear/","page":"Linear Systems","title":"Linear Systems","text":"Some application examples:","category":"page"},{"location":"linear/","page":"Linear Systems","title":"Linear Systems","text":"A1 = [1 2 3;\n     0 1 4;\n     5 6 0]\n\nB1 = [14, 14, 17]\n\n# Output = [1.0, 2.0, 3.0]\nprintln(solve_linear_systems_projective(A1, B1))","category":"page"},{"location":"linear/","page":"Linear Systems","title":"Linear Systems","text":"A2 = [\n    1 0 2 1 0 3 1;\n    0 1 4 0 1 2 0;\n    2 1 0 3 1 0 1;\n    1 2 1 1 0 1 2;\n    0 1 2 0 1 0 3;\n    3 0 1 2 0 1 1;\n    1 1 0 1 2 3 0\n]\n\nB2 = [32, 25, 20, 19, 21, 20, 21]\n\n# Output = [-2.394202898550725, -1.7768115942028986, 3.7594202898550724, 6.83768115942029, \n#           1.4492753623188406,  5.144927536231884,  4.602898550724638]\nprintln(solve_linear_systems_projective(A2, B2))","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"How to install","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This package is not yet registered, so it can't be installed with the Julia package manager. Thus, for installing it, from the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> add https://github.com/VitorLorencone/MinGal.jl","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Or you could also run:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> Using Pkg\njulia> Pkg.add(url=\"https://github.com/VitorLorencone/MinGal.jl\")","category":"page"},{"location":"install/#First-Steps","page":"Installation","title":"First Steps","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Now, to start MinGal, return to Julia mode in REPL and type:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using MinGal","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"The second step to use Mingal is define an Algebra, an environment. The environment is defined through the Algebra() function such as:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> Algebra(3)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"In this case, we created the 3D space. More information about the created space, is just showed in the REPL. By now, try to execute the following command:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> (1+e1e2e3)*(e1)\n1.0*e1 + 1.0*e2e3","category":"page"},{"location":"algebra/#Algebra","page":"Algebra","title":"Algebra","text":"","category":"section"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"The construction of an algebra is the first step for executing code in geometric algebra with MinGal, as it defines the main characteristics for creating the multivector space and its operations.","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"The function Algebra is also described below and is the main function used to initialize spaces.","category":"page"},{"location":"algebra/#Main.MinGal.Algebra-algebra","page":"Algebra","title":"Main.MinGal.Algebra","text":"Algebra(p, [q], [r], [symbols], [type])::Algebra\n\nMain function for creating your Algebra and adding its basis blades to REPL. Constructor Function of an algebraic object with parameters p, q, r, R^{p, q, r}, and its multivector space. If not defined, the last two parameters are automatically calculated as canonical.\n\nArguments\n\np::Int : Represents the ammount of positive dimensions\nq::Int : Represents the ammount of negative dimensions\nr::Int : Represents the ammount of null dimensions\nsymbols::Vector{String} : Array of primary symbols for the Algebra\ntype::String : String for manually selecting \"full\", \"min\" or \"special\" Algebras\n\nReturn\n\nReturns the created Algebra object.\n\n\n\n\n\n","category":"type"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"The function above is responsible for creating the algebra used throughout the code or within the function where it was initialized, as well as instantiating the basis blades and their operations. The canonical blades can be accessed using the symbol e followed by the number representing them. Additionally, it is also possible to store the algebra in a variable and use it to access the blades.","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"using MinGal #hide\nal = Algebra(2, 1)\ne1 + e1e2\nal.e3 * al.e2e3","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"For this example, the created symbols are:","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"Grade-0 blade (Scalar): id the scalar as a multivector type\nGrade-1 blades (Vectors): e1, e2, and e3\nGrade-2 blades (Bivectors): e1e2, e1e3, and e2e3\nGrade-3 blade (Trivector): e1e2e3 or eI the pseudosclalar","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"In degenerate algebras, that is, with a component r different from 0, the first symbol, if not otherwise specified, starts with e0 instead of e1, and the counting of null dimensions begins from that.","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"julia> al = Algebra(2, 0, 1)\n\njulia> e0 * e0\n0.0","category":"page"},{"location":"algebra/#Types","page":"Algebra","title":"Types","text":"","category":"section"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"An algebra can be 'complete', as in AlgebraFull, or 'minimal', as in AlgebraMin. The difference lies in the amount of information stored and preprocessed during its construction, which is chosen automatically or via the type = \"full\" and type = \"min\" parameters in the definition. Additionally, for very large algebras, there is another option, type = \"special\", in which no symbols for the basis blades are constructed, as doing so would be highly inefficient.","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"You can choose this by setting the parameter, or leave it in automatic mode for MinGal to handle. This allows generating algebras in very high dimensions, although with more limited capabilities.","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"In AlgebraFull, all symbols for the generated basis blades are created. In AlgebraMin, only the blades with grade equal to 1, or no blades at all, are generated, depending on the size.","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"using MinGal #hide\nAlgebra(1000)\ne1 + e2 + e1000","category":"page"},{"location":"algebra/#Describe","page":"Algebra","title":"Describe","text":"","category":"section"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"To obtain more information about the generated algebra, such as its metric, symbols, blades, basis, and more, you can use the function describe, as shown in the following example:","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"using MinGal #hide\nal = Algebra(2, 0, 1) #hide\ndescribe(al)","category":"page"},{"location":"algebra/#Custom-Symbols","page":"Algebra","title":"Custom Symbols","text":"","category":"section"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"An interesting possibility for creating algebras is symbol customization, where you can replace the canonical basis blades with the symbols of your choice, and MinGal will automatically concatenate them to form higher grade blades.","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"julia> Complex = Algebra(0, 1, 0, [\"i\"])\n\njulia> i*i\n- 1\n\njulia> (1 + 2*i)^2 * (2 - i)\n- 2 + 11.0*i\n\njulia> Algebra(2, 0, 1, [\"a\", \"b\", \"c\"])\n\njulia> a*a\n0.0\n\njulia> (a + 2abc) \\ bc\n- 2.0*a\n\njulia> eI\n1.0*abc","category":"page"},{"location":"algebra/#Multiple-Algebras","page":"Algebra","title":"Multiple Algebras","text":"","category":"section"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"In order to create and use more than one algebra to perform operations, there are some important points and precautions to take into consideration, as well as best practices and the limitations of MinGal.","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"Each time the Algebra function is executed, an Algebra object and its symbols are created in the REPL so they can be used both with dot notation and by directly writing the symbols. However, conflicts occur when two identical symbols are created, as shown in the example below:","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"julia> R2 = Algebra(2,0,0,[\"i\", \"j\"])\njulia> Complex = Algebra(0,1,0,[\"i\"])","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"In this case, it is always recommended to use dot notation for any operations as a programming best practice. However, it is still possible to use, for example, the symbols created as i and j. The value assigned to j is the one created by R2, since there is no conflict. However, the symbol i takes on the value of Complex because it overwrote the previous definition.","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"Thus, to resolve this conflict and give you full control over which algebra you are working with, you can use dot notation or use the change_algebra command to safely switch the algebra’s symbols. The same applies to the shared symbols id and eI.","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"warning: Warning - change_algebra\nIn high-performance situations, this function is not recommended because it recreates the same symbols again, resulting in suboptimal time complexity; prefer using dot notation. If this is not an issue, then it can be used normally.","category":"page"},{"location":"algebra/","page":"Algebra","title":"Algebra","text":"julia> R2 = Algebra(2,0,0,[\"i\", \"j\"])\njulia> Complex = Algebra(0,1,0,[\"i\"])\n\njulia> i*i\n- 1\n\njulia> j*j\n1\n\njulia> eI\n1.0*i\n\njulia> Complex.i * Complex.i\n- 1\n\njulia> R2.i * R2.i\n1\n\njulia> change_algebra(R2)\n\njulia> i*i\n1\n\njulia> eI\n1.0*ij","category":"page"},{"location":"complex/#Complex-Plane","page":"Complex and Real Spaces","title":"Complex Plane","text":"","category":"section"},{"location":"complex/","page":"Complex and Real Spaces","title":"Complex and Real Spaces","text":"This example demonstrates a way to work with complex numbers using the Mingal library, in a user-friendly manner with regard to notation:","category":"page"},{"location":"complex/","page":"Complex and Real Spaces","title":"Complex and Real Spaces","text":"julia> Complex = Algebra(0, 1, 0, [\"i\"])","category":"page"},{"location":"complex/","page":"Complex and Real Spaces","title":"Complex and Real Spaces","text":"julia> i*i\n- 1\n\njulia> 5i^3\n- 5.0*i\n\njulia> (1+i)*(1+i)\n2.0*i","category":"page"},{"location":"complex/#Real-Spaces","page":"Complex and Real Spaces","title":"Real Spaces","text":"","category":"section"},{"location":"complex/","page":"Complex and Real Spaces","title":"Complex and Real Spaces","text":"This example demonstrates a way to work with the R2 vectors using the Mingal library:","category":"page"},{"location":"complex/","page":"Complex and Real Spaces","title":"Complex and Real Spaces","text":"julia> R2 = Algebra(2,0,0,[\"i\",\"j\"])","category":"page"},{"location":"complex/","page":"Complex and Real Spaces","title":"Complex and Real Spaces","text":"julia> i^i\n0.0\n\njulia> i\\j\n0.0\n\njulia> i^j\n1.0*ij\n\njulia> (i + 2*j)\\(5*i+2*j)\n9","category":"page"},{"location":"design/#Design-and-Project","page":"Design and Project","title":"Design and Project","text":"","category":"section"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"Project and architectural decisions for MinGal","category":"page"},{"location":"design/#Implementation-type","page":"Design and Project","title":"Implementation type","text":"","category":"section"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"According to DIJKMAN (2007) an implementation can be additive or multiplicative. These two approaches differ almost entirely, as their data structures, computational reasoning, implementation complexity, and even algorithm design are fundamentally distinct. MinGal is an additive implementation.","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"The additive approach represents algebraic elements as a weighted sum of basis elements. It is better suited for low-dimensional geometric algebras and is currently the most common approach in computer science.","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"However, there are plans to refactor the library to adopt a multiplicative approach, in order to enable more efficient algorithms for complex problems — which is one of MinGal’s major current limitations.","category":"page"},{"location":"design/#Compression-Type","page":"Design and Project","title":"Compression Type","text":"","category":"section"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"Following the classification of DIJKMAN (2007), a geometric algebra library can employ various forms of coordinate compression in an additive implementation, especially due to the exponential number of elements involved.","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"MinGal adopts coordinate compression as a design choice through the SparseArrays.jl library, which handles sparse vectors by removing zero-valued coordinates.","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"Coordinate compression is the most straightforward compression method, as only nonzero coordinates are stored, with each coordinate tagged to the basis blade it corresponds to.","category":"page"},{"location":"design/#Data-Structures-and-Huge-Dimensions","page":"Design and Project","title":"Data Structures and Huge Dimensions","text":"","category":"section"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"MinGal implements structures for the most essential foundations of geometric algebra — namely, the Algebra itself, Blades, and Multivectors.","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"To achieve this, as previously mentioned, it employs a sparse vector implementation from SparseArrays.jl to ensure coordinate compression and provide high optimization for very large dimensions.","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"As for huge dimensions, where n  62, performance and fast operations are traded off for representing data using Julia’s BigInt library.","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"It is worth noting that many other implementations use a hash table instead of a sparse vector. While this approach offers significantly better scalability, it introduces considerable operational overhead in very high dimensions and also loses the element ordering that the sparse vector representation naturally preserves.","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"So far, MinGal is capable of representing and operating in very high dimensions with n  500000 when the symbolic construction is omitted, leaving only the pure computational representation. However, due to the additive implementation, most operations are not satisfactory, as they tend to be very slow and computationally expensive.","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"Furthermore, in terms of scalability to high dimensions, MinGal implements two main structures for storing the current algebra: AlgebraFull and AlgebraMin. As their names suggest, these structures store different levels of information and user convenience — providing more tools and metadata at lower dimensions, while retaining only the essentials at higher dimensions.","category":"page"},{"location":"design/#Multiple-Dispatch-and-Operator-Overloading","page":"Design and Project","title":"Multiple Dispatch and Operator Overloading","text":"","category":"section"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"It is worth noting that MinGal makes extensive use of safe operator overloading — restricted to the data types defined within the library itself — which greatly improves both code readability and ease of programming.","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"In addition, MinGal includes a dedicated structure for basis blades, ensuring faster and more optimized operations whenever this type is detected. Such type-specific optimizations are easily implemented thanks to Julia’s multiple dispatch mechanism, which was one of the main reasons for choosing the language. It allows for efficient type-based comparisons and dynamic selection of data representations, extending far beyond this particular application.","category":"page"},{"location":"design/#Dual-Algorithms","page":"Design and Project","title":"Dual Algorithms","text":"","category":"section"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"Regarding the implementation of the Dual operation, it is necessary to account for degenerate algebras (those that do not have an inverse of the pseudoscalar of the space) as well as for the inverse dual operation.","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"To handle this, the algorithm implemented checks the parameter r (zero dimension) of the current algebra, selecting between a duality by polarity approach (applying the equation e_i^* = e_i rfloor I^-1) or a Hodge dual approach (directly swapping the blade’s dimensions).","category":"page"},{"location":"design/#Complexity-Analysis","page":"Design and Project","title":"Complexity Analysis","text":"","category":"section"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"Finally, regarding the main challenge of the additive implementation — and of geometric algebra libraries in general — an analysis was conducted on the complexity of all major functions in MinGal.jl, focusing on their memory usage and execution time.","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"It is evident that, in general, the additive approach will always consume memory on the order of O(2^n), as this represents the storage complexity of a multivector.","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"Let n be the dimension of the space n63, and B the number of bits used to represent the bitmap of a blade.","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"Function Time Complexity Space Complexity\nAlgebra O(n2^n) or O(n) O(2^n) or O(n)\nBlade (constructor) O(1) O(1)\nMultivector (constructor) O(2^n) O(2^n)\ncanonical_reordering_sign O(B) equiv O(1) O(1)\ngrade_projection O(B) equiv O(1) O(1)\nscalar_product (Blades) O(B) equiv O(1) O(1)\ngeometric_product (Blades) O(B) equiv O(1) O(1)\ninner_product (Blades) O(B) equiv O(1) O(1)\nouter_product (Blades) O(B) equiv O(1) O(1)\ngeometric_product (Multivectors) O(2^2n) O(2^n)\ninner_product (Multivectors) O(2^2n) O(2^n)\nouter_product (Multivectors) O(2^2n) O(2^n)\nreverse O(2^n) O(2^n)\ninvert O(2^2n) O(2^n)\ndual e undual O(2^n) O(2^n)\nleft_contraction (Multivectors) O(2^2n) O(2^n)\nregressive_product (Multivectors) O(2^2n) O(2^n)","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"For the construction of the algebra, if it is a full algebra, it is necessary to combine all basis blades along with additional constructions. However, if the algebra is minimal, only the basis blades and the metric are required — which explains the difference in time and space complexities shown in the table.","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"The time complexity of products between blades depends on the size of the bitmap. Since we fix, for example, an Int64 to represent the bitmap, for dimensions between 0 and 63 the number of comparisons performed in each blade product remains constant. Thus, in practice, it is reasonable to assume constant-time complexity.","category":"page"},{"location":"design/","page":"Design and Project","title":"Design and Project","text":"However, a divergence appears for higher dimensions, where the bitmap grows due to the need for BigInt representation. In such cases, operations become more expensive, scaling linearly with the number of bits in the bitmap.","category":"page"},{"location":"issues/#Issues-and-Limitations","page":"Issues and Limitations","title":"Issues and Limitations","text":"","category":"section"},{"location":"issues/","page":"Issues and Limitations","title":"Issues and Limitations","text":"Among the issues and limitations already identified in the current version of MinGal, we have:","category":"page"},{"location":"issues/","page":"Issues and Limitations","title":"Issues and Limitations","text":"Julia is accustomed to using the base-10 exponent notation e, as in 1e3 = 1000, which is problematic for geometric algebra notation that also intends to use this to define scalar multiplication on blades. To avoid this, it is easy to change the symbol e in the algebra’s symbol customization or simply write 1*e3. However, we are considering the possibility of completely replacing the symbol due to this incompatibility.\nSwitching algebras currently still creates the symbols that both algebras will use, and it is not possible to remove these old symbols from the REPL, which sometimes results in unnecessary memory usage and ambiguities, as already described in the algebra section.\nDue to errors caused by creating constants after they have been used (World Age Error), calling the Algebra method inside functions means it is always necessary to reference the algebra's constants using dot notation, rather than calling their symbols directly. This is not an issue when you create the algebra outside the functions, but this cannot always be done.\nAs mentioned in other sections, MinGal implements an additive version of geometric algebra, which is not capable of efficiently performing geometric-algebra operations in high dimensions. Thus, although it is possible to create such algebras, they are practically useless for performing any large-scale operations, making a multiplicative implementation of geometric algebra necessary, a potential future plan. \nThere are still some functions that, as the library has evolved, have become outdated, poorly optimized, and sometimes do not even use multiple dispatch correctly, such as functions that accept Multivector but do not accept Blade or vice versa.","category":"page"},{"location":"operations/#Geometric-Operations","page":"Geometric Operations","title":"Geometric Operations","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"Here you will find the main functions implemented by MinGal that you can use in your programs. For each function shown, there is a hyperlink allowing you to access the formal documentation of the function.","category":"page"},{"location":"operations/#Products","page":"Geometric Operations","title":"Products","text":"","category":"section"},{"location":"operations/#Geometric-Product","page":"Geometric Operations","title":"Geometric Product","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The geometric product it is the main product used when working with geometric algebra. Regarding its meaning, as noted by (DIJKMAN): \"The definition is quite abstract. It is the most faithful product of oriented subspaces that one can adopt in order to form a reasonable algebra.\". It can be written in terms of the inner and outer products as:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"AB = A cdot B + A wedge B","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It is applied between Blades and Multivectors and can be computed using the function geometric_product or with the * operator.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> e2 * e1e3\n- 1.0*e1e2e3","category":"page"},{"location":"operations/#Inner-Product","page":"Geometric Operations","title":"Inner Product","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The inner product is one of the three fundamental products of all geometric algebra, and it reduces the grade according to the constituent blades. Let A and B be blades of grades k and l, respectively, then:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"A cdot B = langle AB rangle_k-l","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It is applied between Blades and Multivectors and can be computed using the function inner_product or with the operator \\.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> e2 \\ e1e2\n- 1.0*e1","category":"page"},{"location":"operations/#Outer-Product","page":"Geometric Operations","title":"Outer Product","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The outer product is the last of the three fundamental products of all geometric algebra, and it increases the grade according to the constituent blades. Let A and B be blades of grades k and l, respectively, then:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"A wedge B = langle AB rangle_k+l","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It is applied between Blades and Multivectors and can be computed using the function outer_product or with the operator ^.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> e2^e1e3\n- 1.0*e1e2e3","category":"page"},{"location":"operations/#Scalar-Product","page":"Geometric Operations","title":"Scalar Product","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The scalar product is defined as the scalar part of the geometric product.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"A ast B = langle AB rangle_0","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It is applied between Blades and Multivectors and can be computed using the function scalar_product.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> scalar_product(e1+e3+2, e1e2+1)\n2.0","category":"page"},{"location":"operations/#Left-Contraction","page":"Geometric Operations","title":"Left Contraction","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The left contraction is defined as a product that produces a (k-l)-blade from a k-blade and a l-blade.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"A rfloor B = langle AB rangle_k-l","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It is applied between Blades and Multivectors and can be computed using the function left_contraction or with the operator <<.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> left_contraction(e1+e3+2, e1e2+1)\n2 + 1.0*e2 + 2.0*e1e2","category":"page"},{"location":"operations/#Right-Contraction","page":"Geometric Operations","title":"Right Contraction","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The right contraction is defined as a product that produces a (l-k)-blade from a k-blade and a l-blade.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"A lfloor B = langle AB rangle_l-k","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It is applied between Blades and Multivectors and can be computed using the function right_contraction or with the operator >>.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> right_contraction(e1+e3+2, e1e2+1)\n2 + 1.0*e1 + 1.0*e3","category":"page"},{"location":"operations/#Regressive-Product","page":"Geometric Operations","title":"Regressive Product","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The regressive product is quite similar to a meet (intersection). It is used to perform certain specific intersections, but it is not as general. Basically, the regressive product is the meet in which the join (union) is replaced by the pseudoscalar (I) (PERWASS).","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"A nabla B = (A^* wedge B^*)I","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It is applied between Blades and Multivectors and can be computed using the function regressive_product or with the operator &.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> (e1+e3+2) & (e1e2+eI)\n3 + 1.0*e1 + 1.0*e3","category":"page"},{"location":"operations/#Grade-Functions","page":"Geometric Operations","title":"Grade Functions","text":"","category":"section"},{"location":"operations/#Grade","page":"Geometric Operations","title":"Grade","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The grade of a blade is the number of elements from the Algebra that take part in the geometric product used to generate that blade. It is interesting to note that the grade of a scalar is 0, since no elements are multiplied to obtain it.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The grade of a multivector is the highest grade among all of its constituent blades. It can be computed using the function grade.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> grade(e1e3)\n2\n\njulia> grade(1 + e2 + e3*e1*e2)\n3","category":"page"},{"location":"operations/#Grade-Parts","page":"Geometric Operations","title":"Grade Parts","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"There are additional grade functions that can be computed and used in various situations. This is the case for the functions grade plus, grade minus, and grade null, which return the grade of the multivector considering only the canonical blades whose geometric product is +1, -1 and 0 respectively. Note that:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"gr(A) = gr_+(A)+gr_-(A)+gr_0(A)","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"They can be computed using the functions grade_plus, grade_minus and grade_null.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(2,2,2)\n\njulia> grade_plus(Blade(e0e1e2e3e4e5))\n2\n\njulia> grade_minus(Blade(e0e1e2e3e4e5))\n2\n\njulia> grade_null(Blade(e0e1e2e3e4e5))\n2\n\njulia> grade(Blade(e0e1e2e3e4e5))\n6","category":"page"},{"location":"operations/#Grade-Selection","page":"Geometric Operations","title":"Grade Selection","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"Grade selection is a simple but fundamental operation for many other functions we defined. Thus, we say that the grade projection of a generic blade A onto grade k is:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"langle A rangle_k = begincases\n  A  gr(A) = k \n  0   gr(A) neq k\nendcases","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"An interesting case is that grade selection can be generalized to multivectors, in such a way that it always selects all blades of grade k from that multivector. It can be computed using the function grade_selection.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> grade_selection(1+e1+e2+e1e3+e2e3, 2)\n1.0*e1e3 + 1.0*e2e3","category":"page"},{"location":"operations/#Involutions","page":"Geometric Operations","title":"Involutions","text":"","category":"section"},{"location":"operations/#Revert","page":"Geometric Operations","title":"Revert","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The reverse operation is a unary operation performed on blades and is based on a very simple principle: reversing the order of all constituent elements, that is:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"widetildeA = widetilde(e_1e_2e_k) = (e_ke_2e_1)","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"And by simplifying the expression, where k is the grade of A, we arrive at:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"widetildeA = (-1)^frack(k-1)2A","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It can be computed using the function revert. Or it can be used with the operator \"~\"","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> ~e1e2e3\n- 1.0*e1e2e3","category":"page"},{"location":"operations/#Conjugation","page":"Geometric Operations","title":"Conjugation","text":"","category":"section"},{"location":"operations/#Conjugate","page":"Geometric Operations","title":"Conjugate","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The conjugate operation is a unary operation performed on blades such that:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"AA^dagger = +1","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"Let k be the grade of A and r be the grade_minus of A, then it can be written as:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"A^dagger = (-1)^r(-1)^frack(k-1)2A","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It can be computed using the function conjugate. Notice that it only fulfills its role for non-degenerate algebras!","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> conjugate(e1e2e3)\n- 1.0*e1e2e3","category":"page"},{"location":"operations/#Clifford-Conjugation","page":"Geometric Operations","title":"Clifford Conjugation","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The clifford conjugation operation is a unary operation performed on blades for it's conjugate, similar to the above.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"Let k be the grade of A, then it can be written as:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"barA= (-1)^frack(k+1)2A","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It can be computed using the function clifford_conjugation. Notice that it only fulfills its role for non-degenerate algebras, but may have some applications.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> clifford_conjugation(e1e2e3)\n1.0*e1e2e3","category":"page"},{"location":"operations/#Grade-Involution","page":"Geometric Operations","title":"Grade Involution","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The grade involution operation is a unary operation performed on blades, it toggles the orientation of a blade if it's grade is odd.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"Let k be the grade of A, then it can be written as:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"hatA= (-1)^kA","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It can be computed using the function grade_involution.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> grade_involution(e1e2e3)\n- 1.0*e1e2e3","category":"page"},{"location":"operations/#Inversion","page":"Geometric Operations","title":"Inversion","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The inversion operation is a unary operation performed on blades such that:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"AA^-1 = +1","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The inversion of generic multivectors is quite complicated, but rarely necessary. It is important to note that in degenerate algebras (r neq 0) the nonexistence of an inverse can be common because the geometric product of some basis blades is zero.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"A^-1 = fracwidetildeAAwidetildeA","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It can be computed using the function invert. Notice that it only fulfills its role for non-degenerate algebras and mostly blades supported. You can also use the operator ^-1.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> invert(e1+e2)\n0.5*e1 + 0.5*e2\n\njulia> e1e2e3^-1\n- 1.0*e1e2e3","category":"page"},{"location":"operations/#Dualization","page":"Geometric Operations","title":"Dualization","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The dual operation is a unary operation performed on blades or multivectors. It follows the principle of swapping the dimensions of a blade according to the signature. Note that dualization can be performed in any reference frame, but the pseudoscalar of the space I is the one that gives it the most meaningful interpretation.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"A^* = A rfloor I^-1","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"Also, the undual, the inverse process, is defined as:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"A^-* = A rfloor I","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It is interesting to note that dualization depends on the pseudoscalar being invertible, meaning that it does not work in this form for degenerate algebras. However, with the Hodge dual algorithm, we can also compute it in those cases, simply not using the equation above, but instead directly swapping the dimensions of the blade or multivector.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It can be computed using the function dual or undual. You can also use the operator ! for dual only.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> dual(e1e3)\n- 1.0*e2\n\njulia> undual(-e2)\n1.0*e1e3\n\njulia> !(e1 + 2*e2 + 3*e3)\n- 3.0*e1e2 + 2.0*e1e3 - 1.0*e2e3","category":"page"},{"location":"operations/#Norms","page":"Geometric Operations","title":"Norms","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"A norm is a function that assigns a non-negative (or negative) real-valued ‘length’ to a multivector. There are many multiple norms that can be used.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It is related to (and used to calculate) the magnitude, that generalizes the familiar length of a vector to higher-grade geometric objects (like areas, volumes, etc.) and is the positive scalar value representing the \"size\" of any multivector.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"A generic norm function that works both in degenerate and non-degenerate algebras called norm can be used.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(2,2,1)\n\njulia> norm(2*e1 + e2e3)\n2.23606797749979\n\njulia> norm(2*e0 + e2e3)\n2.23606797749979","category":"page"},{"location":"operations/#Reverse-Norm","page":"Geometric Operations","title":"Reverse Norm","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The reverse norm is a kind of norm defined as:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"A_R^2 = langle A widetildeA rangle_0","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"A_R = sign(A_R^2) sqrtA_R^2","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"In practice the reverse norm is useful, especially due to its possible negative sign. It can be computed using the function reverse_norm.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(2,2,1)\n\njulia> reverse_norm(2*e1 + e2e3)\n1.7320508075688772\n\njulia> reverse_norm(2*e0 + e2e3)\n-1.0","category":"page"},{"location":"operations/#Euclidean-Coefficients-Norm","page":"Geometric Operations","title":"Euclidean Coefficients Norm","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"Let A_k be the k-th blade component of a multivector A, and let S_k be the scalar of A_k, then the euclidean coefficients norm is a kind of norm defined as:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"M_E = sqrtsum_k S_k^2","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It is also good for degenerate algebras because the metric is mostly ignored. It can be computed using the function euclidean_norm.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(2,2,1)\n\njulia> euclidean_norm(2*e1 + e2e3)\n2.23606797749979\n\njulia> euclidean_norm(2*e0 + e2e3)\n2.23606797749979","category":"page"},{"location":"operations/#Conjugate-Norm","page":"Geometric Operations","title":"Conjugate Norm","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The conjugate norm is a norm defined as:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"A_dagger = sqrtlangle AA^dagger rangle_0","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It can be computed using the function conjugate_norm.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(2,2,1)\n\njulia> conjugate_norm(2*e1 + e2e3)\n2.23606797749979\n\njulia> conjugate_norm(2*e0 + e2e3)\n1.0","category":"page"},{"location":"operations/#Clifford-Norm","page":"Geometric Operations","title":"Clifford Norm","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The clifford norm is a norm defined as:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"A_C = sqrtlangle A barA rangle_0","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It can be computed using the function clifford_norm.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(2,2,1)\n\njulia> clifford_norm(2*e1 + e2e3)\n2.23606797749979\n\njulia> clifford_norm(2*e0 + e2e3)\n1.0","category":"page"},{"location":"operations/#Is-Scalar","page":"Geometric Operations","title":"Is Scalar","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The is_scalar is a function that checks where a GAType is a Scalar or not:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It can be computed using the function is_scalar.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> is_scalar(1 + e1 - e1)\ntrue\n\njulia> is_scalar(e1)\nfalse","category":"page"},{"location":"operations/#Is-Blade","page":"Geometric Operations","title":"Is Blade","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The is_blade is a function that checks where a GAType is a Blade or not:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It can be computed using the function is_blade.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> is_scalar(1 + e2)\nfalse\n\njulia> is_scalar(e1e2)\ntrue","category":"page"},{"location":"operations/#Exponential","page":"Geometric Operations","title":"Exponential","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The exponential is a function that computes the exponential of GA elements that squares to a scalar. A more generic function was not yet implemented.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It can be computed using the function exp_ga.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"Algebra(2, 0, 1) # 2DPGA\n\n# Rotate 'a' by an angle 'n' rad from the origin (0,0)\nfunction rotate(a, n)\n    rotor = exp_ga(-e1e2*n/2)\n    return rotor * a * invert(rotor)\nend\n\njulia> exp_ga(-e1e2*pi/4)\n0.7071067811865476 - 0.707*e1e2","category":"page"},{"location":"operations/#Chain","page":"Geometric Operations","title":"Chain","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The chain function 'chains' the canonical basis with a vector of coefficients. It sums the coeff[i]*canonical[i] with the rest, good for translating matrices lines into a GA object.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"It can be computed using the function chain.","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"julia> Algebra(3)\n\njulia> chain([1,2,3])\n1.0*e1 + 2.0*e2 + 3.0*e3","category":"page"},{"location":"operations/#Operator-Overloading-Table","page":"Geometric Operations","title":"Operator Overloading Table","text":"","category":"section"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"The table below summarizes the operator overloading symbols and its functions:","category":"page"},{"location":"operations/","page":"Geometric Operations","title":"Geometric Operations","text":"Operator Function Example\n* geometric_product e1*e2\n* or / product by scalar 2*e2 or e2/2\n\\ inner_product e1\\e2\n^ outer_product e1^e2\n^ exponentiation e1^2\n^-1 invert e1^-1\n== or != comparison e1!=e2\n+ multivector_sum e1+e2\n- multivector_sub e1-e2\n~ revert ~e1\n! dual !e1\n<< left_contraction e1<<e2\n>> right_contraction e1>>e2\n& regressive_product e1&e2","category":"page"},{"location":"objects/#Main-Objects","page":"Main Objects","title":"Main Objects","text":"","category":"section"},{"location":"objects/","page":"Main Objects","title":"Main Objects","text":"MinGal works with several additional data types as well as abstract types to assist in the construction of functions and programs, relying heavily on Julia’s multiple dispatch.","category":"page"},{"location":"objects/#Blade","page":"Main Objects","title":"Blade","text":"","category":"section"},{"location":"objects/","page":"Main Objects","title":"Main Objects","text":"A Blade is a basic construct for many operations and forms what we call Multivectors. Its constructor includes information such as the bitmap and scalar, which make up the internal design of the blade. Although it shares the same struct as multivectors, it has different interpretations and optimizations. Most operations are performed on Multivectors rather than on Blades, but there are still scenarios in which understanding how blades work is useful.","category":"page"},{"location":"objects/","page":"Main Objects","title":"Main Objects","text":"In general, internally, they consist of a bitmap, which indicates which canonical basis blades are present in the construction of that Blade, as well as a scalar. There are functions in MinGal that can only be executed on a Blade and not on a Multivector. For this reason, it is useful to understand the ways to convert and construct Blades, as shown below:","category":"page"},{"location":"objects/","page":"Main Objects","title":"Main Objects","text":"using MinGal #hide\nAlgebra(3)\nBlade(1, 2) # Same as 2.0*e1\nBlade(Multivector([4], [1])) # Only if it's a single blade, same as 1.0*e3\nBlade(3) # Same as 3.0*id","category":"page"},{"location":"objects/","page":"Main Objects","title":"Main Objects","text":"By using additional functions, you can also obtain internal information about a blade.","category":"page"},{"location":"objects/","page":"Main Objects","title":"Main Objects","text":"using MinGal #hide\nAlgebra(3) # hide\nbl = Blade(6, 3) # same as 3.0*e2e3\nbitmap(bl) # or bitstring \"110\"\nscalar(bl)","category":"page"},{"location":"objects/#Multivector","page":"Main Objects","title":"Multivector","text":"","category":"section"},{"location":"objects/","page":"Main Objects","title":"Main Objects","text":"A Multivector is a composition of Blades and is the main structure used by MinGal. Every construction made with the symbols created by the algebra is converted into multivectors. Internally, it is essentially an array of blades with their bitmaps and scalars. In addition, its core structure uses the data structure from the SparseArrays.jl library, with some modifications.","category":"page"},{"location":"objects/","page":"Main Objects","title":"Main Objects","text":"using MinGal #hide\nAlgebra(3)\nMultivector(Blade(1, 1)) # same as 1.0*e1\nMultivector([2, 5], [1, 1]) == 1.0*e2 + 1.0*e1e3\nMultivector([Blade(2,1), Blade(5,1)]) # same as above","category":"page"},{"location":"objects/#Other-Types","page":"Main Objects","title":"Other Types","text":"","category":"section"},{"location":"objects/","page":"Main Objects","title":"Main Objects","text":"Finally, it is worth noting some other types created to support the use of the library, such as GAType, GAVector, and GAArray.","category":"page"},{"location":"objects/","page":"Main Objects","title":"Main Objects","text":"A GAType is an abstract type that encompasses both a Blade and a Multivector. A GAVector is a way of representing a vector of GAType, and the same applies to GAArray, which is a generic array.","category":"page"},{"location":"objects/","page":"Main Objects","title":"Main Objects","text":"using MinGal #hide\nAlgebra(3) #hide\nBlade <: GAType\nMultivector <: GAType\ntypeof(e1+e3) <: GAType\ntypeof(e1+e3) <: Multivector\ntypeof(e1+e3) <: Blade\ntypeof(Multivector[e1, e1e2+2]) <: GAVector","category":"page"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"To begin using the library for problem modeling, geometric structure representation, or any other mathematical application, the first step is always to define the algebra in which we will be working.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"tip: Tip - Algebra\nAn algebra Algebra(p, q, r) is defined by the following parameters:  p: Number of positive dimensions  \nq: Optional number of negative dimensions  \nr: Optional number of null dimensions","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Let's create a 3D Euclidean Vectorspace:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using MinGal\nEuclidean3D = Algebra(3)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Now, the necessary symbols have been automatically created for use throughout the rest of the code. In other words, we have at our disposal:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Grade-0 blade (Scalar): id\nGrade-1 blades (Vectors): e1, e2, and e3\nGrade-2 blades (Bivectors): e1e2, e1e3, and e2e3\nGrade-3 blade (Trivector): e1e2e3 or eI","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Among them, we can perform several operations in geometric algebra. Consider the main ones:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Product by Scalar: k * ei  \nInner Product: ei \\ ej  \nOuter Product: ei ^ ej  \nGeometric Product: ei * ej  ","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Examples:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"julia> (e1*e2 + e3)\\eI\n1.0*e1e2 - 1.0*e3\n\njulia> e1^e1e3\n0.0\n\njulia> (5*e2 - 2*e2e3)/2\n2.5*e2 - 1.0*e2e3","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"These operations produce objects known as Multivectors and can be stored and manipulated like any other data types.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Now that we know the basics, let's try to compute the area of a polygon in R^2 using geometric algebra concepts. For this, recall that in this algebra a point can be represented vectorially as P(xy) = x circ e_1 + y circ e_2","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"point = (x, y) -> return x*e1 + y*e2","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"You can express the area of a polygon (ordered set p of n points) in geometric-algebra terms by triangulating the polygon with a fixed reference point (for example p_1) and summing the areas of the triangles. The area A is: A = frac12 displaystyle sum_i=2^n-1  (p_i-p_1) wedge (p_i+1-p_1)  where p is the norm of a multivector or it's magnitude.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"function area(points)\n    area = 0\n    p1 = points[1]\n    for i in 2:length(points)-1\n        area += (points[i]-p1)^(points[i+1]-p1)\n    end\n\n    return norm(area)/2\nend","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"So, for an ordered set of points points:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"pts = [point(1,2), point(7.4, 2.3), point(4.17, -4.3), point(1.38, -1.12)]\narea(pts)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"For now, you should already know the basics of the most commonly used functions and have seen a small example of what can be done, but there are still many other functions and possibilities, so I suggest taking a look at the next sections and examples to learn more!","category":"page"},{"location":"pga/#2D-PGA-Transformations","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"","category":"section"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"In this example we will illustrate, with the help of the CairoMakie, library, a drawing of a house rotated and translated in the plane so that we can apply geometric-algebra transformations to place it in an ideal position, which will be done in the projective plane (2DPGA).","category":"page"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"pga = Algebra(2,0,1)","category":"page"},{"location":"pga/#Points-and-Lines","page":"2D PGA Transformations","title":"Points and Lines","text":"","category":"section"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"To construct a point, we will create a data type to represent it, as well as a function for its construction.","category":"page"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"mutable struct Point\n    mv::GAType\nend\n\n# P = (x, y)\npoint = (x::Number, y::Number) -> return Point(-x*e0e2 + y*e0e1 + e1e2)","category":"page"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"Similarly, to construct a line segment, we create a data type to store the line object between two points, as well as the start and end points of that segment.","category":"page"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"mutable struct Segment\n    mv::GAType\n    start_point::Point\n    end_point::Point\nend\n\n# S: Line from point `a` to point `b`\nsegment = (a::Point, b::Point) -> return Segment(a.mv & b.mv, a, b)","category":"page"},{"location":"pga/#Transformations","page":"2D PGA Transformations","title":"Transformations","text":"","category":"section"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"Now we can create the transformation functions, such as translation:","category":"page"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"# Translate Point 'a' by (tx,ty)\nfunction translate(a::Point, tx, ty)\n    T = 1 + (tx*e1 + ty*e2)*e0/2\n    return Point(T * a.mv * T^-1)\nend\n\n# Translate Segment 'a' by (tx,ty)\nfunction translate(a::Segment, tx, ty)\n    T = 1 + (tx*e1 + ty*e2)*e0/2\n    return Segment(T*a.mv*T^-1, Point(T*a.start_point.mv*T^-1), Point(T*a.end_point.mv*T^-1))\nend","category":"page"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"And also rotation:","category":"page"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"# Rotate Point 'a' by an angle 'n' rad from the origin (0,0)\nfunction rotate(a::Point, n)\n    R = exp_ga(-e1e2*n/2)\n    return Point(R * a.mv * R^-1)\nend\n\n# Rotate Segment 'a' by an angle 'n' rad from the origin (0,0)\nfunction rotate(a::Segment, n)\n    R = exp_ga(-e1e2*n/2)\n    return Segment(R*a.mv*R^-1, Point(R*a.start_point.mv*R^-1), Point(R*a.end_point.mv*R^-1))\nend","category":"page"},{"location":"pga/#Rendering","page":"2D PGA Transformations","title":"Rendering","text":"","category":"section"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"Let us now initialize the scene using CairoMakie, which should generate an image like the one below:","category":"page"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"# Scene\nfig = Figure()\nax = Axis(fig[1,1])\n\n# Construct a house with segments\nobjects = Segment[]\npush!(objects, segment(point(1, 2), point(1, 8)))\npush!(objects, segment(point(1, 8), point(-3, 8)))\npush!(objects, segment(point(-3, 8), point(-3, 2)))\npush!(objects, segment(point(-3, 2), point(1, 2)))\npush!(objects, segment(point(-3, 2), point(-6, 5)))\npush!(objects, segment(point(-6, 5), point(-3, 8)))\npush!(objects, segment(point(1, 6), point(-2, 6)))\npush!(objects, segment(point(1, 4), point(-2, 4)))\npush!(objects, segment(point(-2, 6), point(-2, 4)))\n\n# Render everything with CairoMakie\nfor obj in objects\n    lx = [-obj.start_point.mv[e0e2], -obj.end_point.mv[e0e2]]\n    ly = [obj.start_point.mv[e0e1], obj.end_point.mv[e0e1]]\n    lines!(ax, lx, ly, color = :red, linewidth = 2)\nend\n\nsave(\"2DPGA.png\", fig)","category":"page"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"<img src=\"../assets/2DPGA-1.png\" alt=\"Generated Image\" width=\"70%\">","category":"page"},{"location":"pga/#Result","page":"2D PGA Transformations","title":"Result","text":"","category":"section"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"Finally, we will apply the correct rotation and translation transformations to the image:","category":"page"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"# Translate everything by (-1, -2) -> Origin\nobjects = map(a -> translate(x, -1, -2), objects)\n\n# Rotate everything by -pi/2 rad -> Right direction\nobjects = map(a -> rotate(a, -pi/2), objects)","category":"page"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"Finally, rendering the new image now we have:","category":"page"},{"location":"pga/","page":"2D PGA Transformations","title":"2D PGA Transformations","text":"<img src=\"../assets/2DPGA-2.png\" alt=\"Image after transformations\" width=\"70%\">","category":"page"},{"location":"shorthand/#Shorthand-Methods","page":"Shorthand Methods","title":"Shorthand Methods","text":"","category":"section"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"Here we will learn about some ways to write expressions, notations, and constructions of basic structures in a more compact form, assisted by MinGal.","category":"page"},{"location":"shorthand/#Selecting-Elements-on-a-Multivector","page":"Shorthand Methods","title":"Selecting Elements on a Multivector","text":"","category":"section"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"When working with Multivectors you will notice the need to select a specific element, such as a blade, grade, scalar, and so on. Below I list some ways to make this selection:","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"The first and most direct way is to choose the element by its index in bit-order notation, simply by using bracket notation [k]. However, since this notation is difficult to understand, it is usually not used in practice. Selection in this form begins with the grade-0 blade (the scalar) always at index 0. Thus, it is a viable option if you only want the scalar value of a multivector, but it is also worth noting that the function scalar does exactly that.","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"julia> Algebra(3)\n\njulia> a = -1 + e1 + 2*e2 + 3*e3 + 4*e1e2 + 5*e1e3 + 6*e2e3 + 7*e1e2e3\n- 1 + 1.0*e1 + 2.0*e2 + 4.0*e1e2 + 3.0*e3 + 5.0*e1e3 + 6.0*e2e3 + 7.0*e1e2e3 # Bit-Order\n\njulia> a[0] # Scalar\n-1\n\njulia> scalar(a)\n-1\n\njulia> a[1] # e1\n1\n\njulia> a[2] # e2\n2\n\njulia> a[3] # e1e2\n4","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"Another way to do the same thing is to apply the Multivector element inside the brackets, making it easier to understand and to select the scalars of each constituent blade.","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"julia> Algebra(3)\n\njulia> a = -1 + e1 + 2*e2 + 3*e3 + 4*e1e2 + 5*e1e3 + 6*e2e3 + 7*e1e2e3\n\njulia> a[id] # Scalar\n-1\n\njulia> a[e1]\n1\n\njulia> a[e2e3]\n6","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"Finally, grade selection has a dedicated function for this, grade_selection, which selects all blades of a given grade.","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"julia> Algebra(3)\n\njulia> a = -1 + e1 + 2*e2 + 3*e3 + 4*e1e2 + 5*e1e3 + 6*e2e3 + 7*e1e2e3\n\njulia> grade_selection(a, 0)\n- 1\n\njulia> grade_selection(a, 1)\n1.0*e1 + 2.0*e2 + 3.0*e3\n\njulia> grade_selection(a, 2)\n4.0*e1e2 + 5.0*e1e3 + 6.0*e2e3\n\njulia> grade_selection(a, 3)\n7.0*e1e2e3","category":"page"},{"location":"shorthand/#Setting-Elements-on-a-Multivector","page":"Shorthand Methods","title":"Setting Elements on a Multivector","text":"","category":"section"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"As described in the section above, the same constructions can be used, as can be seen in the example below:","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"julia> Algebra(3)\n\njulia> a = -1 + e1 + 2*e2 + 3*e3 + 4*e1e2 + 5*e1e3 + 6*e2e3 + 7*e1e2e3\n\njulia> a[0] = 3\n3 + 1.0*e1 + 2.0*e2 + 4.0*e1e2 + 3.0*e3 + 5.0*e1e3 + 6.0*e2e3 + 7.0*e1e2e3\n\njulia> a[e1e2] = 0\n3 + 1.0*e1 + 2.0*e2 + 3.0*e3 + 5.0*e1e3 + 6.0*e2e3 + 7.0*e1e2e3","category":"page"},{"location":"shorthand/#Key-and-Values","page":"Shorthand Methods","title":"Key and Values","text":"","category":"section"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"In order to verify the existence of elements and their values in a Multivector, we can use the special functions below. Furthermore, they provide possibilities for more controlled iteration when needed.","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"The keys function returns the indices in bit-order of all elements present in the multivector’s internal structure. The values function does the same, in the same order, but with the values associated with each of those indices, that is, the scalar value of each key.","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"julia> Algebra(3)\n\njulia> a = -1 + e1 + 2*e2 + e2e3 + 7*e1e2e3\n\njulia> keys(a)\n[0, 1, 2, 6, 7]\n\njulia> values(a)\n[-1, 1, 2, 1, 7]\n\njulia> res = 0\njulia> for (i, val) in zip(keys(a), values(a))\n           res += Blade(i, val)\n       end\n\njulia> res\n- 1 + 1.0*e1 + 2.0*e2 + 1.0*e2e3 + 7.0*e1e2e3","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"Finally, we can check whether a key exists using the haskey function. It works both with the numeric index and with the written representation of the corresponding multivector.","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"julia> Algebra(3)\n\njulia> a = -1 + e1 + 2*e2 + e2e3 + 7*e1e2e3\n\njulia> haskey(a, 1) # e1\ntrue\n\njulia> haskey(a, e1e3)\nfalse\n\njulia> haskey(a, eI)\ntrue","category":"page"},{"location":"shorthand/#Size-and-Length","page":"Shorthand Methods","title":"Size and Length","text":"","category":"section"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"Two useful functions allow you to determine the number of elements in a multivector and also its maximum possible size. The size function is more internal and always returns the maximum value for the algebra of that multivector. The length function, on the other hand, returns the number of elements currently present in the multivector’s internal structure at the moment it is called.","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"julia> Algebra(3)\n\njulia> a = -1 + e1 + 2*e2 + e2e3 + 7*e1e2e3\n\njulia> size(a)\n8\n\njulia> length(a)\n5\n\njulia> a += 1 - e1\n\njulia> length(a)\n3","category":"page"},{"location":"shorthand/#Iterating-over-a-Multivector","page":"Shorthand Methods","title":"Iterating over a Multivector","text":"","category":"section"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"In short, iterating over multivectors is quite simple and can be done in several ways, as demonstrated above. However, in a more simplified manner, we can do:","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"julia> Algebra(3)\n\njulia> a = -1 + e1 + 2*e2 + e2e3 + 7*e1e2e3\n\njulia> for blade in a\n           println(blade)\n       end\n- 1\n1.0*e1\n2.0*e2\n1.0*e2e3\n7.0*e1e2e3","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"If you want to iterate only over the canonical basis blades of an algebra, you can use the function canonical_basis, thus it is also possible to write:","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"julia> al = Algebra(3)\n\njulia> for blade in canonical_basis(al)\n           println(blade)\n       end\n1.0*e1\n1.0*e2\n1.0*e3\n\njulia> for (index, blade) in pairs(canonical_basis())\n           println(index*blade)\n       end\n1.0*e1\n2.0*e2\n3.0*e3","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"Furthermore, if you need greater control over the entire set of basis blades of an algebra, you can, in a slightly more complex manner, use bit manipulation by shifting the bit-order index to return the element you want. You can also simply proceed as you normally would, for example:","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"julia> al = Algebra(3)\njulia> n = al.p + al.q + al.r\n\njulia> for i in 0:(al.max-1)\n           println(Blade(i,1))\n       end\n1\n1.0*e1\n1.0*e2\n1.0*e1e2\n1.0*e3\n1.0*e1e3\n1.0*e2e3\n1.0*e1e2e3\n\njulia> for j in 1:n\n           println(Blade(1<<(j-1),1))\n       end\n1.0*e1\n1.0*e2\n1.0*e3","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"If it is necessary to iterate over a GAVector or similar structures in order to combine all elements into a single operation, a simpler alternative to using a basic for loop is to apply Julia’s reduce method to simplify the process, which is very useful in various geometric algebra computations.","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"julia> Algebra(3)\n\njulia> vec = [e1, e3, e2, id] \n\njulia> typeof(vec) <: GAVector\ntrue\n\njulia> reduce(^, vec; init=Blade(1)) # same as e1^e3^e2^id\n- 1.0*e1e2e3","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"Finally, the chain method is also useful for helping associate a vector of elements with the canonical basis vectors, which is very handy for converting matrix rows into geometric-algebra multivectors.","category":"page"},{"location":"shorthand/","page":"Shorthand Methods","title":"Shorthand Methods","text":"julia> Algebra(3)\n\njulia> vec = [1, 2, 3]\n\njulia> chain(vec)\n1.0*e1 + 2.0*e2 + 3.0*e3","category":"page"},{"location":"#MinGal.jl","page":"Home","title":"MinGal.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Geometric Algebra library written in Julia","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This page is dedicated to document the use of MinGal, a library for Geometric Algebra. Our goal is to provide an accessible and easy to learn experience for students and researchers interested in using (and programming with) a Geometric Algebra library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Our aim is to offer a relatively simple, open, easy-to-install, and focused environment for Julia users. This library was developed by implementing basic operations as described in textbooks, without an emphasis on optimizing functions based on other libraries. For the future, the plans are to expand the ease of use and introduce concepts for modeling and visualizing spaces in Geometric Algebra.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This project is continually evolving, and many aspects are being refined to achieve better results.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A foundational understanding of the theoretical aspects of Geometric Algebra is highly recommended. We suggest the following references:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Christian Perwass, Geometric Algebra with Applications in Engineering, Springer Series in Geometry and Computing, 2009.\nL.Dorst, D.Fontijne and S.Mann, Geometric Algebra for Computer Science: an object oriented approach to geometry, Morgan Kaufman publishers, 2007.\nD. H. F. Dijkman, Efficient Implementation of Geometric Algebra. Univ. of Amsterdam, 2007.","category":"page"},{"location":"#Developed-By","page":"Home","title":"Developed By","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is being developed as part of a scientific initiation program at the State University of Maringá.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Vitor Madeira Lorençone - Student\nEmerson Vitor Castelani - Professor","category":"page"}]
}
